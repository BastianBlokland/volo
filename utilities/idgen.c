#include "app/cli.h"
#include "cli/app.h"
#include "cli/parse.h"
#include "cli/read.h"
#include "cli/validate.h"
#include "core/alloc.h"
#include "core/array.h"
#include "core/dynstring.h"
#include "core/file.h"
#include "core/path.h"
#include "core/version.h"
#include "data/read.h"
#include "data/utils.h"
#include "log/logger.h"
#include "log/sink_json.h"
#include "log/sink_pretty.h"

/**
 * IdGenerator - Utility to generate a header with pre-hashed strings.
 */

typedef struct {
  String outputPath;
  String prefix;
  HeapArray_t(String) entries;
} IdGenConfig;

static DataMeta g_idGenConfigMeta;

static void idgen_data_init(void) {
  // clang-format off
  data_reg_struct_t(g_dataReg, IdGenConfig);
  data_reg_field_t(g_dataReg, IdGenConfig, outputPath, data_prim_t(String), .flags = DataFlags_NotEmpty);
  data_reg_field_t(g_dataReg, IdGenConfig, prefix, data_prim_t(String), .flags = DataFlags_NotEmpty);
  data_reg_field_t(g_dataReg, IdGenConfig, entries, data_prim_t(String), .container = DataContainer_HeapArray, .flags = DataFlags_NotEmpty);
  // clang-format on

  g_idGenConfigMeta = data_meta_t(t_IdGenConfig);
}

static bool idgen_config_load(const String path, IdGenConfig* out) {
  bool       success = false;
  File*      file    = null;
  FileResult fileRes;
  if ((fileRes = file_create(g_allocHeap, path, FileMode_Open, FileAccess_Read, &file))) {
    log_e("Failed to open config file", log_param("err", fmt_text(file_result_str(fileRes))));
    goto Ret;
  }
  String data;
  if ((fileRes = file_map(file, 0 /* offset */, 0 /* size */, FileHints_Prefetch, &data))) {
    log_e("Failed to map config file", log_param("err", fmt_text(file_result_str(fileRes))));
    goto Ret;
  }
  DataReadResult result;
  const Mem      outMem = mem_create(out, sizeof(IdGenConfig));
  data_read_json(g_dataReg, data, g_allocHeap, g_idGenConfigMeta, outMem, &result);
  if (result.error) {
    log_e("Failed to parse config file", log_param("err", fmt_text(result.errorMsg)));
    goto Ret;
  }
  success = true;

Ret:
  if (file) {
    file_destroy(file);
  }
  return success;
}

static void idgen_config_destroy(IdGenConfig* cfg) {
  data_destroy(g_dataReg, g_allocHeap, g_idGenConfigMeta, mem_create(cfg, sizeof(IdGenConfig)));
}

static String idgen_config_out_path_scratch(const IdGenConfig* cfg, const String cfgPath) {
  return path_build_scratch(path_parent(cfgPath), cfg->outputPath);
}

static bool idgen_run(const IdGenConfig* cfg, const String outPath) {
  log_i(
      "Generating ids",
      log_param("version", fmt_text(version_str_scratch(g_versionExecutable))),
      log_param("executable", fmt_path(g_pathExecutable)),
      log_param("entries", fmt_int(cfg->entries.count)),
      log_param("output-path", fmt_path(outPath)));

  bool      success   = true;
  DynString outBuffer = dynstring_create(g_allocHeap, usize_kibibyte * 16);

  fmt_write(&outBuffer, "#pragma once\n");
  fmt_write(&outBuffer, "// Generated by '{}'.\n\n", fmt_text(path_stem(g_pathExecutable)));
  fmt_write(&outBuffer, "// clang-format off\n");
  fmt_write(&outBuffer, "enum {\n");
  heap_array_for_t(cfg->entries, String, val) {
    fmt_write(&outBuffer, "  ");
    dynstring_append(&outBuffer, cfg->prefix);
    fmt_write(&outBuffer, "Id_");
    dynstring_append(&outBuffer, *val); // TODO: Either validate or escape invalid chars (eg space).
    fmt_write(&outBuffer, " = {}, // {}\n", fmt_int(string_hash(*val)), fmt_text(*val));
  }
  fmt_write(&outBuffer, "};\n");
  fmt_write(&outBuffer, "// clang-format on\n");

  if (file_write_to_path_sync(outPath, dynstring_view(&outBuffer)) != FileResult_Success) {
    log_e("Failed to write output", log_param("path", fmt_path(outPath)));
    success = false;
    goto Ret;
  }

Ret:
  dynstring_destroy(&outBuffer);
  return success;
}

static CliId g_optConfigPath, g_optVerbose;

AppType app_cli_configure(CliApp* app) {
  cli_app_register_desc(app, string_lit("Id generator utility."));

  g_optConfigPath = cli_register_arg(app, string_lit("config"), CliOptionFlags_Required);
  cli_register_desc(app, g_optConfigPath, string_lit("Path to a id-gen config file."));
  cli_register_validator(app, g_optConfigPath, cli_validate_file_regular);

  g_optVerbose = cli_register_flag(app, '\0', string_lit("verbose"), CliOptionFlags_None);

  return AppType_Console;
}

i32 app_cli_run(MAYBE_UNUSED const CliApp* app, const CliInvocation* invoc) {

  const LogMask logMask = cli_parse_provided(invoc, g_optVerbose) ? LogMask_All : ~LogMask_Debug;
  log_add_sink(g_logger, log_sink_pretty_default(g_allocHeap, g_fileStdOut, logMask));
  log_add_sink(g_logger, log_sink_json_default(g_allocHeap, LogMask_All));

  idgen_data_init();

  const String cfgPath = cli_read_string(invoc, g_optConfigPath, string_empty);
  IdGenConfig  cfg;
  if (!idgen_config_load(cfgPath, &cfg)) {
    return 1;
  }
  const String outPath = string_dup(g_allocHeap, idgen_config_out_path_scratch(&cfg, cfgPath));

  i32 retCode = 0;
  if (!idgen_run(&cfg, outPath)) {
    retCode = 1;
    goto Done;
  }

Done:
  string_free(g_allocHeap, outPath);
  idgen_config_destroy(&cfg);
  return retCode;
}
